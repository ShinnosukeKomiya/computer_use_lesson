このレッスンの終わりまでに、長いプロンプトのコストを最大90%削減し、レイテンシーを最大85%削減するためのプロンプトキャッシングの使用方法を習得できるようになります。
では、始めてみましょう。
まず、プロンプトキャッシングが実際に何をするのか理解することから始めましょう。どのような利点があり、どのように機能するのでしょうか。
基本的に、プロンプトキャッシングは、プロンプトに共通する特定のプレフィックスから再開できるようにすることで、API使用を最適化するのに役立つ機能です。
簡単に言えば、一つのAPIコールから次のAPIコールまで一貫性を保つものをキャッシュすることができ、反復的なタスクやプロンプトの処理時間とコストを大幅に削減できます。
では、コードに入る前にいくつかの図を見てみましょう。
左側に仮想的なプロンプトがあります。形で表現しているだけです。これは送信するプロンプトです。最初は何もキャッシュされていません。
このリクエストをAPIに送信します。処理されます。そして、APIに送信するすべてをキャッシュすることにしましょう。
この時点で、最初のリクエストからの以前のプロンプト、プロンプトプレフィックスのすべてがキャッシュに保存されています。
次のリクエストでは、より長いプロンプトがあります。最初のリクエストと全く同じプレフィックスが含まれていますが、その後に多くの追加があります。
APIはもはやプロンプト全体を処理する必要はありません。以前のターンからプレフィックスをキャッシュしました。
この新しいリクエストを送信すると、キャッシュヒットが発生し、キャッシュから読み取ります。つまり、それらのトークンを再処理する必要がありません。
トークン数に応じて、多くの時間を節約でき、繰り返し使用する場合には多くのお金も節約できます。
そして、キャッシュにさらに書き込みを行い、会話が成長するにつれて増分的にキャッシュに追加することができます。または、プロンプトの特に長い部分だけをキャッシュすることもできます。
ノートブックに戻ると、これまでと同じ基本的なセットアップがあります。Anthropicをインポートし、クライアントをセットアップし、モデル名の文字列変数があります。
プロンプトキャッシングの最も明白な違いを見るために、プロンプトキャッシングありとなしの場合で、非常に長いプロンプトを使用します。
実際にメアリー・シェリーの「フランケンシュタイン」の本文全体を使用します。これはFrankenstein.txtというファイルで利用可能です。
最初のステップは、そのファイル全体を開いて内容を読み込むことです。変数に入れます。この場合は「book_content」と呼びます。コンテンツは非常に長い文字列になります。
ここに見えるように、その一部のスライスがあります。本の内容の一部を見ることができます。
次のステップは、本全体を送信することです。「第3章で何が起こりますか？」といったような簡単なプロンプトとともに送ります。
ここではどんな簡単なプロンプトでも構いません。理想的には「フランケンシュタイン」の本に関連したものがよいでしょう。
これはすべて「make_non_cash_API_call」という関数の中にあります。リクエストの送信前後でタイミングを計るロジックが含まれていることがわかります。基本的にリクエストの送信から応答の受信までの時間を計算しようとしています。
そして最後に、関数は全体の応答と、開始時間と終了時間の差分であるデルタを返します。
明確にしておくと、このバージョンはまったくキャッシングを使用していません。
ハイライトされた行は、その大きな文字列である本の内容全体が提供されている場所です。
bookのXMLタグで囲まれていることに注目してください。必須ではありませんが、モデルにとって分離するのに良い方法です。
これは大きな文書です。そして最後に、質問「第3章で何が起こりますか？」があります。これは実際の本とは別になっています。
つまり、この大きな本の境界を区切っているのです。
次のステップは関数を呼び出すことです。
この行が関数を呼び出します。この行は時間がどれくらいかかったかを出力します。そしてこの行はモデルから返される実際のコンテンツを出力します。
セルを実行して待ちます。これは非常に長いプロンプトなので、時間がかかるかもしれません。
応答が返ってきました。この特定のインスタンスでは17.77秒かかりました。
繰り返しますが、まったくキャッシングは関与していません。
ここに実際の応答がありますが、正直なところ、この関数で最も重要ではありません。時間の要素と、ここにある実際の使用量に焦点を当てることが重要です。
入力トークンが108,000トークン、それに続いて324の出力トークンが処理されたことがわかります。
これは生成に使用されたトークンの数です。そしてキャッシュ作成入力トークンとキャッシュ読み取りトークンはゼロです。まだキャッシングを全く関与させていないからです。
次に、明示的なキャッシングAPIを活用する、キャッシュバージョンに移ることができます。
これは以前のものとほぼ同じ関数ですが、"make_cached_API_call"と呼ばれ、キャッシュなしの代わりに、ここに非常に重要な追加があります。
この大きな本のコンテンツを提供しているコンテンツブロックで、タイプがephemeralの辞書に設定されたキャッシュ制御プロパティまたはキーがあります。
キャッシュポイントを設定したい場合、基本的にAPIに「この時点までのすべての入力トークンをキャッシュして、次回再利用できるようにしたい」と伝えます。
APIはそれを行います。キャッシュに書き込みたいことを知るためには、このタグを探す必要があります。
これを実行すると、最初は依然として長い時間がかかります。まだキャッシュに書き込んでいないため、キャッシュヒットはありません。
実行できます。まだ何もキャッシュされていないので時間がかかりますが、このリクエストの一部として、このキャッシュ制御までの入力トークンがキャッシュされます。
実行が終わりました。これが返ってくる可能性のある応答です。モデルが実際に生成したすべてのコンテンツです。
しかし、私たちの目的では、ここが最も重要な部分です。入力トークンは今回11としかカウントされていません。出力トークンは324です。そしてキャッシュ作成入力トークンは108,427です。
大量のトークンが現在キャッシュに保存されています。
次のステップはそれらから読み取ることを試みることです。
先ほど実行した関数に戻ると、このキャッシュ制御タグは実際に二重の目的で機能します。
APIがこれに最初に遭遇したとき、この時点までキャッシュ書き込みを実行します。108,000トークンすべてをキャッシュに書き込みます。そして、後続のリクエストでは、このキャッシュ制御ポイントに遭遇したとき、この時点までキャッシュされているものがあるかどうかを確認します。
基本的に読み取りポイントとして機能します。
つまり、書き込みポイントと読み取りポイントとして機能する二重の目的があります。
全く同じ関数を送信できます。同じ関数を実行し、APIに全く同じリクエストを送信します。
これは今度は読み取りとして機能します。この行を再度実行できます。
新しい変数名、response2、duration2です。実行が終わりました。
response2の使用プロパティを見ることができます。cache_creation_input_tokenはゼロです。キャッシュへの書き込みは実行されなかったからです。キャッシュ読み取り入力トークンは108,000トークンです。
前のターンと比較すると、キャッシュ作成入力トークンは108,000、キャッシュ読み取りはゼロでした。
全く同じリクエストの形状、同じメッセージです。今回はキャッシュ読み取りがあったため、キャッシュへの書き込みはありませんでしたが、キャッシュからの大規模な読み取りがありました。
duration2を見ると、6.2秒です。完全にキャッシュなしのバージョンの17秒と比較してください。
全く同じプロンプトです。一つ小さな違いがあります。このバージョンは第3章で何が起こるかを尋ね、このバージョンは第5章で何が起こるかを尋ねましたが、基本的に全く同じ長さのプロンプトで、最後の数字が異なるだけです。
17.7秒に対して6.2秒です。
そしてこれはコスト削減を考慮していません。
では、それについて話しましょう。プロンプトキャッシングの価格設定は非常に簡単です。
基本的に、キャッシュに書き込むために少しプレミアムを支払います。キャッシュ書き込みトークンは通常の基本入力トークンよりも25%高価です。
しかし、キャッシュ読み取りの時には大きな利点があります。キャッシュからの読み取りトークンは、キャッシュなしの基本入力トークンよりも90%安価です。
そして、実際の入力と出力、キャッシュされていないものと生成される出力は、標準価格のままです。
これは、すべてのメッセージのすべてのものをキャッシュすることが意味をなさない可能性があることを意味します。
しかし、多くのリクエストで同じままであるプロンプトプレフィックスがある場合、その長いプレフィックスをキャッシュして再利用することは非常に効率的でコスト効果が高くなる可能性があります。
キャッシュ書き込みに一度25%多く支払い、その後のキャッシュヒットを得るすべてのリクエストでそれらの入力トークンに90%少なく支払います。
さて、キャッシュヒットについて言えば、重要な注意点の一つは、キャッシュは永遠に存在しないということです。
各キャッシュには5分のTTL（生存時間）があります。現在、少なくともエフェメラルキャッシングのみをサポートしており、キャッシュから読み取るたびに、その5分のタイマーがリセットされます。
したがって、ユースケースとキャッシングの使用方法、送信するプロンプトの種類にも本当に依存します。
しかし、長い長いプロンプトがあり、お金を節約したい場合で、そのプロンプトの多くを再利用している場合はいつでも、プロンプトキャッシングを使用できます。
プロンプトキャッシングの一般的な落とし穴の一つは、マルチターン会話のキャッシングです。
例えば、非常に長い会話があるとします。おそらく「フランケンシュタイン」の本に関する会話で、モデルにその本文全体が送信され、それについての会話が行われています。
キャッシュすべき長い共通のプレフィックスがあり、特に会話に数十または数百のターンがあり、各ターンが長い場合にトークンを節約できます。
会話が成長するにつれてキャッシュすることができます。
キャッシュ制御ポイントを設定することで、これは実際に書き込みポイントとしても機能することを覚えておいてください。この時点までのすべてをキャッシュに書き込み、読み取りポイントとして機能します。
マルチターン会話で作業する場合、会話を下に移動させる2つのキャッシュ制御ポイントを使用して、最後のユーザーメッセージを常にキャッシュし、最後から2番目のユーザーメッセージにキャッシュ制御ポイントを持つことができます。
なぜそうするのでしょうか？どのように機能するのでしょうか？
再び、これは二重の目的の性質に起因します。
これが何百ものメッセージを持つ非常に長い会話だと想像してください。
このキャッシュ制御ポイントはおそらく前のターンからの読み取りを得るでしょう。これは以前は最後のユーザーメッセージでしたが、応答を得ました。これは以前にキャッシュへの書き込みが行われた最後のメッセージで、現在は読み取りとして機能します。
キャッシュヒットが発生し、そして最後のこの部分が、新しい書き込みポイントとして機能し、APIに「ここまでのすべてを書き込んでください」と伝えます。
そしてこのパターンを続けます。会話が成長する場合、このメッセージリストが示すように、同じパターンです。最後から2番目のユーザーメッセージにキャッシュ制御を置き、最後のユーザーメッセージにキャッシュ制御を置きます。
繰り返しますが、これはAPIに「この時点までのすべてを書き込んでください」と伝えます。これは新しく、「この時点から読み取れるものすべてを読み取ってください」というものです。
なぜなら、このメッセージ「火星についてもっと教えて」は以前は最後のメッセージだったからです。
そしてこのパターンを続け、これらのキャッシュ制御を会話の下に移動させ、最後のユーザーメッセージと最後から2番目のユーザーメッセージに対して、最新のキャッシュから継続的に読み取り、会話の終わりまで書き込みを行い、次回読み取ることができるようにし、これを何度も繰り返します。
これは人々を混乱させることがあります。これは私たちのドキュメントにあり、もちろんこのノートブックにもあります。
ここではリクエストを行っていません。これは参考例として参照できるメッセージリストに過ぎません。しかし、繰り返しますが、人々を戸惑わせることがあります。
最後に、computer useに話を戻すと、これは過去数回のレッスンで見てきたcomputer useのクイックスタートデモからの小さな抜粋です。
実際にキャッシュ制御を使用していることを強調したいと思います。キャッシュ制御はタイプがephemeralに設定され、かなりの数のトークンを占める可能性のある多くのスクリーンショットを含むモデルとの長いメッセージ履歴をキャッシュします。
そのため、このモデルがアクションを実行し、2分か3分、あるいは4分の相互作用で、何かを試し、スクリーンショットを撮り、10個の異なるスクリーンショットと、まだ議論していない多くの異なるツール呼び出しがある場合、キャッシングは実際のcomputer useの時間とコストを大幅に削減できます。
後でこのコードをより詳しく見る機会があります。これは主に「見てください、キャッシングは教育用ノートブックだけでなく、実際の現場でも使用されています」ということを示すためのものです。
